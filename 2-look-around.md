Отличие от других средств
=========================
Здесь идет понимание возможностей известных вариантов и их применимости для [поставленной задачи](1-task.md).

# Шелл-скрипты
* В шелл-скриптах нет способа автоматически откатывать внесенные скриптами изменения.
* Нет способа удалить часть в середине шелл-скрипта, и автоматически сделать так,
чтобы это удаление как-то возымело эффект при повторном запуске скрипта
(т.е. внесенные изменения в удаленном участке откатились бы с машины.)

Преимущества: для шелл Zsh создано [много плагинов](https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins)

# Пакетные менеджеры
Пакетный менеджер (apt, npm, pacman, ...) может сделать код доступным, т.е. [установить его](https://medium.com/swlh/introduction-to-debian-maintainer-script-flow-charts-6f76423b80d9),
и на этом всё.

Нам же требуется не просто сделать код доступным, а уметь его вызвать, причем с разными командами и с разными параметрами.

По сути, нам требуется развитый механизм dependencies, где вместо "типов" используются "экземпляры".
Пакетные менеджеры же работают именно на уровне типов. Например, далее подробный разбор npm.

# Пакетный менеджер Npm

[Алгоритм Npm](https://docs.npmjs.com/cli/install#algorithm) очень близок к желаемому нам.
Однако он нацелен на то, чтобы скачать или обновить коды.

Нам же требуется:
- уметь выполнить код с заданными параметрами.
- уметь выполнить несколько экземпляров кода.
- вызвать удаление кода, когда он больше не требуется (npm это умеет).

Npm можно доработать - это научить указывать не просто список depenencies, 
но и параметры их работы. И добавить возможность указывать несколько экземпляров 
одинакового depenency, но с разными параметрами.

А если не использовать механизм npm dependencies, то его упоминание и вовсе становится бессмысленным. 
Потому что тогда придется все делать собственно самим - отслеживать появившиеся и удаленные
строчки в скриптах и прочее. Возвращаемся к ситуации "шелл-скрипты".

Интерес вселяет [проект npx](https://medium.com/devschacht/introducing-npx-an-npm-package-runner-a72a658cd9e6), 
это не просто выполнить dependencies, но и вызвать команду. Возможно, году к 2025 npm-агломерация добавит возможности,
на достижение которых направлен Zapusk.

# Ansible
* Проблемы полностью аналогичные шелл-скриптам. [Ansible](https://ru.wikipedia.org/wiki/Ansible) действует только вперед, нет отката назад,
нет отслеживания что применилось, а что нет.
* Сложная система с точки зрения её расширения.

Преимущество: изначальная поддержка remote-машин. Много модулей. Возможно Zapsuk-у стоит поддержать проксирование
zdb-вызовов в [модули Ansible](https://docs.ansible.com/ansible/latest/modules/modules_by_category.html).

# Terraform
> [Terraform](https://www.terraform.io/) allows infrastructure to be expressed as code in a simple, 
> human readable language called HCL (HashiCorp Configuration Language). Terraform CLI reads configuration files 
> and provides an execution plan of changes, which can be reviewed for safety and then applied and provisioned.

Есть облачная версия, и есть стадия [plan](https://www.terraform.io/docs/commands/plan.html). Мощный [язык](https://www.terraform.io/docs/configuration/index.html), можно впечатляться.

Получается, что в принципе Terraform это аналог Zapusk. Преимущества Zapusk в том, что:
* Zapusk поддерживает произвольные команды. Terrafrom поддерживает [только apply и destroy](https://www.terraform.io/docs/commands/index.html)
(не удалось найти возможности добавить свои команды). Возможно, какая-то другая логика для разных целей пользователя есть.
* [Спецификация Zapusk](https://github.com/pavelvasev/zapusk/blob/master/spec-1.md) проста,
и каждому в принципе реально реализовать свой zapusk-tool, который сможет использовать существующие модули (lib).
Это путь к свободе.

# Прочие
Kubernetes, SaltStack, Ansible, AWS CloudFormation, Puppet, Chef.
Отличия хорошо описаны в [terraform vs other](https://www.terraform.io/intro/vs/index.html).
Собственно, мы с ним согласны.

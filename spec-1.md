Zapusk Спецификация 1
=====================
 * [Запуск-программа](#Запуск-программа)
 * [Алгоритм выполнения запуск-программы](#Алгоритм-выполнения-запуск-программы)
   - [Тип шагов](#Тип-шагов)
   - [Пространства имен экземпляров компонент](#Пространства-имен-экземпляров-компонент)
   - [Отслеживание состояния компонент](#Отслеживание-состояния-компонент)
   - [Особенности выполнения](#Особенности-выполнения)
 * [Синтаксис](#Синтаксис)
   - [Вычисление значений параметров](#Вычисление-значений-параметров)
 * [Специальные параметры](#Специальные-параметры)
 * [Специальные шаги](#Специальные-шаги)
   - [os](#os)
   - [info](#info)
   - [commands](#commands)
   - [once](#once)
   - [file](#file)
   - [guard](#guard)
   - [load](#load)
   - [when](#when)
 * [Репозитории](#Репозитории)
 * [Авторы](#Авторы)

Запуск-программа
================
Запуск-программа это программа, предназначенная для того, чтобы привести машину в требуемое состояние.
В широком смысле цель запуск-программы - производить реакцию на те или иные команды, поступающие к ней.
Одной из реакций может быть настройка машины, но возможны и другие по смыслу реакции.

Программа реагирует на различные команды, включая две особые:
* `apply` -- достичь цели
* `destroy` -- отменить внесенные изменения.

Программа состоит из следующих частей:

1. Набор параметров и их значений.
Значения параметров могут быть переназначены при запуске программы.
Также при запуске могут быть добавлены новые параметры и их значения.

2. Набор компонент.
Каждый компонент имеет уникальный идентификатор. 
Порядок компонент важен.

3. Каждый компонент содержит набор шагов.
Каждый шаг имеет набор параметров и их значений, включая идентификатор и тип шага. 
Порядок шагов важен.

Программа выполняется интепретатором.

Алгоритм выполнения запуск-программы
====================================

Интерпретатор получает на входе:
* запуск-программу
* запрос на выполнение
сопровождаемый а) именем команды и б) перечнем дополнительных параметров запроса.

Интерпретатор обработывает поступивший запрос по алгоритму:

1. Запрос по очереди передается компонентам программы.
2. При поступлении запроса в компоненту, этот запрос передается первому шагу этой компоненты.
3. Шаг определяет реакцию на команду, и в его семантике происходит решение, следует ли передавать запрос
следующему шагу данной компоненты, и какой это будет запрос (этот же самый, или какой-то другой).
4. В конце концов обработка запроса в данной компоненте прекращается, и запрос передается следующей
компоненте программы.

Вышеописанный процесс сопровождается расчетом параметров по следующему алгоритму.

1. Программа имеет список собственных параметров. При поступлении запроса, этот список 
объединяется со списком параметров запроса (параметры запроса имеют приоритет выше).
2. Компоненты своих параметров не имеют.
3. Каждый шаг имеет свои параметры. В значениях этих параметров могут быть формулы, 
включающие ссылки на другие параметры этого шага, а также ссылки на текущие параметры программы.
При выполнении шага, все формулы для его личных параметров - вычисляются.

## Тип шагов

У каждого шага есть тип. Если тип известен интерпретатору, он реагирует на него сам.

Если тип шага интерпретатору неизвестен, то считается что этот тип шага является идентификатором внешней 
запуск-программы, и производится её поиск и выполнение. При этом параметры этого шага становятся
параметрами запроса к запускаемой запуск-программе.

## Пространства имен экземпляров компонент

Интерпретатор отслеживает развитие пространства имен. При запуске подпрограммы, интерпретатор
назначает ей префикс имени, связанный с конкретным путем программ и компонент, вызвавших эту программу.
Таким образом, каждый экземпляр запускаемой подпрограммы имеет вполне конкретный символьный
идентификатор, уникальный во всём вычислении, и может его использовать по своему усмотрению.

> см. далее global_name

## Отслеживание состояния компонент

Интерпретатор ведет учет применяемых компонент, и код, ассоциированный с конкретной компонентой,
имеет локальное (по отношению к этой компоненте) хранилище данных.

> см. далее state_dir

## Особенности выполнения

Интерпретор предоставляет шагам возможность при необходимости останавливать выполнение всей запуск-программы.

> см. далее код возврата 100


Синтаксис
=========

Запуск-программа записывается в форме каталога вида `имя.zdb`, содержащем 1 или более файлов расширением `ini`.

Каталог может содержать и другие файлы и подкаталоги, для интерпретатора это значение не имеет.

Интерпретатор упорядочивает и считывает все файлы *.ini, находящиеся на первом уровне каталога программы, 
объединяет их в общее содержимое, и анализирует.

Синтаксис содержимого - это набор компонент, обозначаемых заголовками 
в формате `###### component-name ######` (требуется не менее 3х символов `#`), 
и далее у каждой компоненты задаётся перечень её шагов в формате ini.
Каждый шаг обозначается своей `[секцией]`.

Пример кода:
```
################## params #####################
alfa=5
beta=8

################## comp1 ######################
[info]
apply=Performing deeds with alfa={{alfa}}

[os]
apply=echo {{alfa}} > {{beta}}.conf
destroy=rm -f {{beta}}.conf

################## comp2 ######################
[os]
apply=/etc/init.d/nginx start
restart=/etc/init.d/nginx restart
```

Здесь:
* `######### params ########` это обозначение для набора параметров программы.
* alfa, beta - параметры программы
* `##### comp1 #####` и `####### comp2 ######` - компоненты и их идентификаторы.
* `[info]` и `[os]` - шаги компонент.
* apply, destroy, restart - параметры шагов.

Вышеуказанная программа содержит описание параметров программы и 2 компоненты (comp1 и comp2).
Компонента comp1 содержит 2 шага - `[info]` и `[os]`. Компонента comp2 содержит 1 шаг - только `[os]`.

Выполнение данной программы с командой apply повлечет три действия:
1. Печать на экран сообщения **Performing deeds with alfa=5**
2. Выполнение команды **echo 5 > 8.conf**.
3. Выполнение команды **/etc/init.d/nginx start**

Выполнение данной программы с командой restart повлечет одно действие:
1. Выполнение команды **/etc/init.d/nginx restart**

## Вычисление значений параметров
Значения параметров - строковые. Они интерполируются:

* {\`some command\`} - выполнить shell-команду some command и вставить ее stdout. Этот вид вычисления выполняется после выполнения всех вычислений вида {{name}}.
* {{name}} - вставить значение параметра name.

Порядок поиска параметров (где первым нашли то и используется):
1. Параметры запуск-программы.
2. Параметры текущей компоненты.
3. Параметры zapusk.conf
4. Специальные параметры.
5. Глобальные параметры.

Если параметр не находится, это вызывает ошибку и запуск-программа останавливается.

Если значение параметра не указывается, оно полагается равным true.
Дальше это может использоваться в зависимости от контекста.

Специальные параметры
=====================

Запуск-программам в дополнение к обычным параметрам доступны следующие специальные параметры:
* **name** -- имя компоненты, вызвавшей zdb-программу. У корневой zdb-программы это имя каталога. Например: `comp1`
* **global_name** -- путь по стеку от корневой к текущей zdb-программе. Например: `alfa-beta-comp1`.
* **state_dir** -- каталог состояния zdb-программы. В него можно писать и читать файлы, подкаталоги.
* **zdb_dir** -- каталог zdb-программы.
* **zdb_type** -- "тип" zdb-программы (совпадает с именем каталога).
* **zapusk_tool** -- путь к файлу zapusk инструмента zapusk-tool.
* **zapusk_tool_dir** -- каталог где размещен zapusk-tool.

Специальные шаги
================

Каждый шаг в zapusk имеет тип. Например:
```
################# my-component
[info]
...
[os]
...
```
В этой компоненте определены 2 шага - один с типом info, другой с типом os.

Тип шага определяет, что должно происходить:
* Если это специальный тип, то происходит реакция согласно описанию ниже.
* В других случаях считается что это идентификатор запуск-программы,
описанной в каталогах lib. Это называется **zdb-тип**.

[Код специальных шагов в zapusk-tool](https://github.com/pavelvasev/zapusk-tool/tree/master/src.v1/types)

## os
Предназначение: выполнить команду shell операционной системы

Пример:
```
################# params
somedir=alfa 15

################# my-component
[os]
apply=mkdir -p {{somedir}}
destroy=rm {{somedir}}
fill=echo 123>{{somedir}}/file.txt
```

Результат: 
* При прохождении команды **apply** будет вызвана команда shell **mkdir -p alfa-15**.
* При прохождении команды destroy будет вызвана команда shell **rm alfa-15**
* При прохождении команды fill будет вызвана команда **echo 123>{{somedir}}/file.txt**
* При прохождении других команд ничего сделано не будет.

После выполнения **[os]** не передает управление следующим шагам -- компонента завершает свою работу.

Примечания:
* Если команда вернула код возврата 100, это считается запросом остановить обработку следующих компонент в текущем zdb-типе.
* Если команда вернула ненулевой код возврата, это считается ошибкой, и выполнение всей запуск-программы останавливается.
* Можно указать особый параметр **default**, который означает получение всех команд.

Примечания zapusk-tool:
* Команда shell выполняется в текущем каталоге состояния.
* Если первое слово строчки shell совпадает с именем какого-нибудь файла в запуск-каталоге данной компоненты,
то оно будет заменено на полый путь к этому файлу.
* Командам shell передаются дополнительные переменные окружения: 
  * ZAPUSK_DEBUG - если действует режим отладки то "--debug" и пустая в противном случае.
  * ZAPUSK_PADDING - текущий отступ в строках вывода zapusk-tool 
  * ZAPUSK_DEFERRED_PATH - путь к файлу отложенных заданий.

## info
Предназначение: напечатать дополнительное пояснение

Пример:
```
################# my-component
[info]
system-update=Установка системного ПО
refresh=Обновление конфигурации
```
Результат: 
* при прохождении команды system-update будет напечано
сообщение **Установка системного ПО**. 
* При прохождении команды **refresh** будет напечатано **Обновление конфигурации**. 
* При прохождении других команд ничего напечатано не будет.

После обработки **[info]** передает управление следующему шагу.

## commands
Предназначение: преобразовать текущую команду в новые команды
и передать их последующим шагам.

Пример:
```
################# my-component
[commands]
apply=do1,do2
play=do2
destroy=remove-me

[os]
do1=echo doing 1
do2=echo doing 2
remove-me=echo destroying
```
Результат:
* При прохождении команды **apply** будут напечатаны строки **doing 1** и **doing 2**.
Это произойдет за счет того, что apply превратится в 2 вызова команд - **do1** и **do2**
* При прохождении команды **play** будет напечатана строка **doing 2**
* При прохождении команды **do1** ничего напечатано не будет. Потому что команда **do1**
не перечислена в шаге [commands]. Аналогично и для **do2**
* При прохождении команды **destroy** будет напечатана строка **destroying**.

Примечание
* Команда **destroy** проходит всегда, даже если не перечислена в **[commands]**.
* Можно не указывать значение параметра, тогда команда заменяется на команду **apply**.

Пример 2:
```
######################## my-component
[commands]
system-update

[os]
apply=ruby update-the-system.rb
destroy=ruby rollback.rb
```
Результат: 
* При прохождении команды **system-update** она будет заменена на apply, управление передано следующему узлу **[os]**,
и произойдет вызов **ruby update-the-system.rb**
* При прохождении команды **destroy** она будет передана без изменений узлу **[os]** и произойдет вызов **ruby rollback.rb**.

## once
Предназначение: сделать так, чтобы какая-то команда в контексте компонента выполнилась только 1 раз.

Пример:
```
##################### my-component
[commands]
apply=install-prerequisties,apply

[once]
install-prerequisties

[os]
install-prerequisties=apt-get install deboostrap guile
apply=perform-main-job.sh
```
Результат:
При прохождении команды **apply**:
1. шаг **[commands]** заменит ее на две команды **install-prerequisties** и **apply**,
2. шаг **[once]** при прохождении через него **install-prerequisties** произведет проверку, проходила
ли эта команда через него ранее. Если проходила - он не пропустит эту команду дальше.
Если команда еще не проходила - пропустит и сохранит отметку о прохождении, чтобы не пропускать
в дальнейшем.
3. шаг os будет выполнять те команды, которые в него придут.

Примечания.
* Команды, не перечисленные в **[once]**, передаются на следующий шаг без каких-либо проверок и изменений.
* Признак прохождения сохраняется в состоянии компоненты.
* Особый параметр **dir** позволяет поменять место хранения состояния. Таким образом можно делать once-проверки
общемашинного уровня.

Пример 2:
```
###################### my-component
[once]
update
dir=/var/zapusk-global-once/

...
```
Результат: какая бы запуск-программа не проходила через данную once-проверку, она будет использовать
общий каталог признаков. Таким образом, update в данном примере выполнится 1 раз на всей машине
и далее выполнятся не будет.

## file
Предназначение: записать файл с указанным содержимым в указанный путь.

Примечание:
* При прохождении любой команды, кроме **destroy**, шаг **[file]** будет записывать файл с указанным содержимым.
* При прохождении команды **destroy** шаг **[file]** удалит созданный им файл.
* При смене пути path созданный ранее файл будет удален.
* **ВАЖНО**: [file] не передает управление следующим шагам в текущем блоке.

Параметры:
* **path** - путь к файлу. Текущим каталогом является state_dir.
* **content** - содержимое файла.
* **mode** - права доступа к файлу. Можно использовать числа или символы.
Примеры: 755, +x, u=wrx,go=rx. Необязательный параметр.

Пример:
```
####################### some-component
[file]
path=/etc/nginx/snippets/my-snippet.conf
content="
 location /hello/ {
   return 408;
 }
"
####################### do-nginx-reload
[os]
apply=/etc/init.d/nginx reload
destroy=/etc/init.d/nginx reload
```

Результат примера:
* При прохождении команды **apply** будет создан файл **/etc/nginx/snippets/my-snippet.conf** и произведен вызов **/etc/init.d/nginx reload**
* При прохождении команды **destroy** будет удален файл **/etc/nginx/snippets/my-snippet.conf** и произведен вызов **/etc/init.d/nginx reload**

## guard

Предназначение: позволяет создать общий разделяемый ресурс, который не будет подвергнут destroy пока не исчезнут
все его запуск-пользователи (т.е. какие-либо развернутые компоненты запуск-программ). 

Пример:
```
####################### some-component
[guard]
key=some-key
dir=/var/zapusk-guards/

[os]
apply=echo applied
destroy=echo destroyed
```

Результат:
* При прохождении любой команды, будет сохранен признак того, что компонента global_name участвует в использовании области защиты (dir,key).
* При прохождении команды **destroy**, данный признак будет снят. Если в области защиты (dir,key) не остается других принаков,
то команда destroy будет пропущена к следующему за [guard] шагу.


## load

Предназначение: подключение zdb-подпрограммы из произвольной папки

Пример:
```
############################# my-program
[load]
dir=/some/path
alfa=5
beta=7
```

Результат: будет загружена запуск-программа из каталога /some/path с входными параметрами alfa=5 и beta=7
Все команды, поступающие в my-program, будут переданы в загруженную подпрограмму.

## when

Статуc: идея
Предназначение: пропускать команды только согласно расписанию

Пример:
```
############################## my-program
[when]
day_of_week=1 6 0

[os]
apply=echo Hello!
```

Результат: будет напечатан текст Hello! если сейчас понедельник, суббота или воскресение.

Репозитории
===========

* [zapusk](https://github.com/pavelvasev/zapusk) - спецификация и примеры
* [zapusk-tool](https://github.com/pavelvasev/zapusk-tool) - программа интерпретатор
* [zapusk-lact-libs](https://github.com/pavelvasev/zapusk-lact-libs) - zdb-типы LineAct

Авторы
=========
2020 Павел Васёв, Михаил Бахтерев
MIT license
